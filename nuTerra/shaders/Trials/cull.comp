#version 450 core

#extension GL_ARB_shading_language_include : require
#extension GL_ARB_shader_atomic_counter_ops : require
#include "common.h"

layout (local_size_x = 1) in;


struct ModelInstanceRange {
	uint instance_offset;
	uint instance_count;
	uint draw_offset;
	uint draw_count;
};

layout (binding = 0, std430) readonly buffer CandidateDraws
{
    CandidateDraw draw[];
};

layout (binding = 1, std430) writeonly buffer OutputDraws
{
    DrawElementsIndirectCommand command[];
};

layout(binding = 2, std430) buffer MODEL_MATRIX_BLOCK
{
    ModelInstance models[];
};

layout(binding = 3, std430) readonly buffer MODEL_RANGE_BLOCK
{
    ModelInstanceRange model_ranges[];
};

layout(binding = 4, std430) writeonly buffer MODEL_INSTANCE_MAPPING_BLOCK
{
    uint model_instance_mapping[];
};

layout (binding = 0, offset = 0) uniform atomic_uint commandCounter;
layout (binding = 0, offset = 4) uniform atomic_uint baseInstanceCounter;

uniform mat4 projection;
uniform mat4 view;

struct Frustum {
	vec4 planes[6];
};

void loadFrustum(out Frustum f, mat4 mvp)
{
	for (int i = 0; i < 3; ++i)
	for (int j = 0; j < 2; ++j) {
		f.planes[i*2+j].x = mvp[0][3] + (j == 0 ? mvp[0][i] : -mvp[0][i]);
		f.planes[i*2+j].y = mvp[1][3] + (j == 0 ? mvp[1][i] : -mvp[1][i]);
		f.planes[i*2+j].z = mvp[2][3] + (j == 0 ? mvp[2][i] : -mvp[2][i]);
		f.planes[i*2+j].w = mvp[3][3] + (j == 0 ? mvp[3][i] : -mvp[3][i]);
		f.planes[i*2+j]*= length(f.planes[i*2+j].xyz);
	}
}

vec3 negativeVertex(vec3 bmin, vec3 bmax, vec3 n)
{
	bvec3 b = greaterThan(n, vec3(0));
	return mix(bmin, bmax, b);
}

bool frustumCullingTest(mat4 mvp, vec3 bmin, vec3 bmax)
{
	float a = 1.0f;
	Frustum f;

	loadFrustum(f, mvp);
	for (int i = 0; i < 6 && a >= 0.0f; ++i) {
		vec3 n = negativeVertex(bmin, bmax, f.planes[i].xyz);

		a = dot(vec4(n, 1.0f), f.planes[i]);
	}

	return (a >= 0.0);
}

void main(void)
{
    const ModelInstanceRange range = model_ranges[gl_GlobalInvocationID.x];

    int instanceToDraw = 0;

    for (int i = 0; i < range.instance_count; ++i) {
        const ModelInstance thisModel = models[range.instance_offset + i];
        const mat4 MVP = projection * view * thisModel.matrix;
        if (true) {
            ++instanceToDraw;
            models[range.instance_offset + i].inFrustum = true;
        } else {
            models[range.instance_offset + i].inFrustum = false;
        }
    }

    if (instanceToDraw > 0) {
        uint baseInstance = atomicCounterAddARB(baseInstanceCounter, instanceToDraw);

        int j = 0;
        for (int i = 0; i < range.instance_count; ++i) {
            if (models[range.instance_offset + i].inFrustum) {
                model_instance_mapping[baseInstance + j] = range.instance_offset + i;
                ++j;
            }
        }

        for (int i = 0; i < range.draw_count; ++i) {
            const CandidateDraw thisDraw = draw[range.draw_offset + i];
            uint outDrawIndex = atomicCounterIncrement(commandCounter);
            command[outDrawIndex].count = thisDraw.count;
            command[outDrawIndex].instanceCount = instanceToDraw;
            command[outDrawIndex].firstIndex = thisDraw.firstIndex;
            command[outDrawIndex].baseVertex = thisDraw.baseVertex;
            command[outDrawIndex].baseInstance = baseInstance;
        }
    }
}
